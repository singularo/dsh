#!/bin/bash

# `set +e` is used to continue on errors throughout this script.
set -euo pipefail

# Used as the prefix for docker networking, container naming and nginx hostname.
export PROJECT=$(basename ${PWD})
export DOCKER_COMPOSE_FILE="docker-compose.$(uname | tr '[:upper:]' '[:lower:]').yml"

# Ultimately permit overriding repo docker-compose.yml with custom file.
if [ -f docker-compose.yml ]; then
  export DOCKER_COMPOSE_FILE='docker-compose.yml'
fi

# Set user variables
export USER_ID=$(id -u ${USER})
export GROUP_ID=$(id -g ${USER})

# Setup some functions to output warnings.
notice()  { printf "\e[32;01m$1\e[39;49;00m\n" }
warning() { printf "\e[33;01m$1\e[39;49;00m\n" }
error()   { printf "\e[31;01m$1\e[39;49;00m\n" }

# Ensure script is NOT running inside a container - must be run from host.
if [ -f /.dockerenv ]; then
  error "Inception error - you can't run $0 within a docker container."
  exit
fi

# Add functionality to the dsh setup/start function
setup_nginx() {
  # Check if its running/exists already and start if required.
  if docker ps -a --format "{{.Names}}" | grep nginx-proxy > /dev/null; then
    docker start nginx-proxy > /dev/null
  else
    echo "Starting nginx proxy"
    docker run -d -p 8080:80  \
      -v /var/run/docker.sock:/tmp/docker.sock:ro \
      --restart always --name nginx-proxy \
      jwilder/nginx-proxy:latest
  fi

  if ! docker ps --format "{{.Names}}" --filter "name=nginx-proxy" > /dev/null; then
    error "jwilder/nginx-proxy could not be started."
  fi

  set +e
  export URL="http://${PROJECT}.${DOMAIN}:8080"
  NGINX_IP=$(docker inspect --format "{{with index .NetworkSettings.Networks \"${PROJECT}_default\"}}{{.IPAddress}}{{end}}" nginx-proxy)
  if [[ ! ${NGINX_IP} =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    notice "Connecting nginx-proxy to the network."
    docker network connect ${PROJECT}_default nginx-proxy
  fi
  set -e
}

# Add functionality to the dsh stop function
stop_nginx() {
  if [ "${USE_NGINX}" == "1" ]; then
    if docker network ls --format "{{.Name}}" --filter "name=${PROJECT}_default" > /dev/null; then
      notice "Disconnecting nginx proxy from network."
      set +e
      docker network disconnect ${PROJECT}_default nginx-proxy > /dev/null
      set -e
    fi
  fi
}

# Command: ./dsh start
# Configures environment then brings up project using docker-compose.yml file.
dsh_start() {
  notice "Starting project containers."
  if [[ ! $(docker network ls --format "{{.Name}}" --filter "name=${PROJECT}_default") =~ "${PROJECT}_default" ]]; then
    docker network create ${PROJECT}_default
  fi
  setup_nginx

  docker-compose -f ${DOCKER_COMPOSE_FILE} up -d
  export URL="http://${PROJECT}.${DOMAIN:-172.17.0.1.xip.io}"
  notice "Please wait about 10 seconds for the database to settle.
You can now access the site from ${URL}.
Project files are available in /code, You may need to build and install your
  project before it starts working.
Connecting via ./dsh shell and running robo build is a common next step."
}

# Command: ./dsh shell
# Connects a shell to the web image as the current user.
dsh_shell() {
  dsh_start

  docker-compose -f ${DOCKER_COMPOSE_FILE} exec \
   -e COLUMNS="$(tput cols)" \
   -e LINES="$(tput lines)" \
   web ${@:-./dsh_bash}
}

# Command: ./dsh stop
# Stops project and brings down network after disconnecting nginx proxy.
dsh_stop() {
  notice "Stopping containers."
  docker-compose -f ${DOCKER_COMPOSE_FILE} stop
}

# Command: ./dsh down
# Stops project, then takes down containers and removes volumes if possible.
dsh_down() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} down -v
}

# Command: ./dsh purge
# Stops project, then takes down containers, removes volumes and remove dev image.
dsh_purge() {
  dsh_down
  docker rmi -f singularo/s2i-shepherd-drupal-dev
}

# Command: ./dsh status
# Shows status information about project containers.
dsh_status() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} ps
}

# Command: ./dsh logs
# Tails logs from web container.
dsh_logs() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} logs -f web
}

dsh_project() {
  set +e
  if [ -f dsh.project ]; then
    source dsh.project
  fi
  set -e
}

# Command: ./dsh pull
# Fetches all images used by the project.
dsh_pull() {
  # docker-compose doesn't resolve sub-dependencies in Dockerfiles.
  docker pull singularo/s2i-shepherd-drupal
  docker-compose -f ${DOCKER_COMPOSE_FILE} pull --ignore-pull-failures
  docker-compose -f ${DOCKER_COMPOSE_FILE} build
}

# Command: ./dsh nfs
# Sets up NFS integration for OSX.
NFS_FILE=/etc/exports
NFS_LINE="/Users -alldirs -mapall=${USER_ID}:${GROUP_ID} localhost"
dsh_setup_nfs() {
  if [ $(uname) != "Darwin" ]; then
    echo "This script is OSX-only. Please do not run it on any other Unix."
    exit 1
  fi

  if [[ ${EUID} -eq 0 ]]; then
    echo "This script must NOT be run with sudo/root. Please re-run without sudo." 1>&2
    exit 1
  fi

  echo ""
  echo " +-----------------------------+"
  echo " | Setup native NFS for Docker |"
  echo " +-----------------------------+"
  echo ""

  echo "WARNING: This script will shut down running containers."
  echo ""
  echo -n "Do you wish to proceed? [y]: "
  read DECISION

  if [ "${DECISION}" != "y" ]; then
    echo "Exiting. No changes made."
    exit 1
  fi

  echo ""

  if ! docker ps > /dev/null 2>&1 ; then
    echo "== Waiting for docker to start..."
  fi

  open -a Docker

  while ! docker ps > /dev/null 2>&1 ; do sleep 2; done

  echo "== Stopping running docker containers..."
  docker-compose -f ${DOCKER_COMPOSE_FILE} down > /dev/null 2>&1
  docker volume prune -f > /dev/null

  osascript -e 'quit app "Docker"'

  echo "== Resetting folder permissions..."
  sudo chown -R "${USER_ID}:${GROUP_ID}" .

  echo "== Setting up nfs..."
  sudo cp /dev/null "${NFS_FILE}"
  grep -qF -- "${NFS_LINE}" "${NFS_FILE}" || sudo echo "${NFS_LINE}" | sudo tee -a "${NFS_FILE}" > /dev/null

  LINE="nfs.server.mount.require_resv_port = 0"
  FILE=/etc/nfs.conf
  grep -qF -- "${LINE}" "${FILE}" || sudo echo "${LINE}" | sudo tee -a "${FILE}" > /dev/null

  echo "== Restarting nfsd..."
  sudo nfsd restart

  echo "== Restarting docker..."
  open -a Docker

  while ! docker ps > /dev/null 2>&1 ; do sleep 2; done

  echo ""
  echo "SUCCESS! Now go run your containers 🐳"
}

# Command: ./dsh rnfs
# Removes nfs setup.
dsh_remove_nfs() {
  if [ $(uname) != "Darwin" ]; then
    echo "This script is OSX-only. Please do not run it on any other Unix."
    exit 1
  fi

  if [[ ${EUID} -eq 0 ]]; then
    echo "This script must NOT be run with sudo/root. Please re-run without sudo." 1>&2
    exit 1
  fi

  echo "== Removing nfsd exports..."
  sudo sed -i '' "/$(echo "${NFS_LINE}" | sed 's/\//\\\//g')/d" ${NFS_FILE}
  echo "== Restarting nfsd..."
  sudo nfsd restart
  echo "== Done"
}

dsh_help() {
  printf "\nUsage: dsh COMMAND\n
Commands:
\tdown\tShutdown and destroy the containers.
\texec\tExecute a command in the container.
\thelp\tShow this help.
\tlogs\tShow the container logs with tail -f - ctrl-c to exit.
\tpull\tPull the latest container images.
\tpurge\tPurge the docker containers, network and proxy and remove all data.
\tshell\tStart a shell which is connected to the containers and can be used to run commands.
\tstart\tStart the docker containers, network and proxy.
\tstatus\tShow the status of this projects containers.
\tstop\tStop the docker containers, network and proxy, but keep data for a re-start.
Mac specific setup:
\tnfs\tSetup NFS for macOS.
\trnfs\tRemove NFS for macOS.
\nIf no command is given, shell is the default.
Commands can be shortened to their uniqe component, eg ./dsh sh is the same as ./dsh shell.\n\n"
}

# Set a default command to show usage when no arguments provided.
COMMAND=${1:-default}

case ${COMMAND} in
  dow*)
    dsh_down
    ;;
  e*)
    dsh_shell ${@:2}
    ;;
  h*|-h|--help)
    dsh_help
    ;;
  l*)
    dsh_logs
    ;;
  nfs)
    dsh_setup_nfs
    ;;
  pul*)
    dsh_pull
    ;;
  pur*)
    dsh_purge
    ;;
  rnfs)
    dsh_remove_nfs
    ;;
  sh*|ss*)
    dsh_shell ${@:2}
    ;;
  star*)
    dsh_start
    ;;
  stat*)
    dsh_status
    ;;
  sto*)
    dsh_stop
    ;;
  *)
    warning "Unknown command specified, defaulting to shell. For other options try:\n$0 [down|help|logs|purge|shell|start|status|stop].\n"
    dsh_shell
    ;;
esac
